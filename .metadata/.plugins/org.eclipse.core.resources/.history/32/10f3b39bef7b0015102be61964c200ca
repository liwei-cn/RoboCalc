#include <cstdlib>
#include <cstring>
#include <sys/time.h>
#include <sys/stat.h>
#include <math.h>
#include "parameters.h"
#include "agent.h"
#include "myWorld.h"

#include "viewer/Viewer.h"
#include <enki/PhysicalEngine.h>
#include <enki/robots/e-puck/EPuck.h>
#include <QtGui/QApplication>
#include <QtGui/QtGui>
#include <iostream>
#include <fstream>

gsl_rng *rng;
void gsl_init();

using namespace Enki;
using namespace std;

class EnkiViewer : public ViewerWidget
{
protected:
	unsigned timeMultiplier;
	int timerId;
	myWorld* myworld;
	QVector<EPuck*> epucks;

public:
	EnkiViewer(myWorld* world, unsigned timeMultiplier = 1, QWidget *parent = 0) :
		ViewerWidget(world, parent),
		timeMultiplier(timeMultiplier)
	{
		myworld = world;
		timerId = startTimer(100);  //0.1s timer
        // Define viewer camera position and altitudes
        altitude= world->h;
        pos = QPointF(-world->w * 0.5, -world->h * 0);
	}

    void addRobots(myWorld* world,int NoRobots)
    {
        for(int i=0;i<NoRobots;i++) {
            EPuck *epuck = new EPuck(0x2);                                      // Initialize new EPuck with camera
            epuck->pos = Point((world->w)*gsl_rng_uniform(rng),(world->h)*gsl_rng_uniform(rng));    // Random initial position
            epuck->angle = 2.0*M_PI*(gsl_rng_uniform(rng) - 0.5);                                 // Random initial orientation
            epuck->leftSpeed = 12.8;                                             // Left motor speed
            epuck->rightSpeed = 12.8;                                            // Right motor speed                                  // Random initial phase
            world->addObject(epuck);                                            // Add Epuck to the world
        }
    }

	virtual void timerEvent(QTimerEvent * event)
	{
		if (event->timerId() == timerId)
		{
			bool finished = false;
			for (unsigned i = 0; i < timeMultiplier; i++)
			{
				finished =  myworld->runStep();
				if (finished)
					break;
			}
			updateGL();

			if (finished)
				close();
		}
	}

	virtual void wheelEvent(QWheelEvent * event)   //zoom in or out the video through middle button of mouse
	{
		if (event->delta() > 0)
			timeMultiplier *= 2;
		else if (event->delta() < 0 && timeMultiplier > 1)
			timeMultiplier /= 2;
		setWindowTitle(QString(tr("Simulation running at %0 times real-time").arg(timeMultiplier)));
	}

    virtual void sceneCompletedHook()  //put some texts over the video
    {
        glColor3d(0,0,0);
//        renderText(10, height()-50, tr("rotate camera by moving mouse while pressing ctrl+left mouse button"));
//        renderText(10, height()-30, tr("move camera on x/y by moving mouse while pressing ctrl+shift+left mouse button"));
//        renderText(10, height()-10, tr("move camera on z by moving mouse while pressing ctrl+shift+right mouse button"));
        renderText(5, 15, QString(tr("Simulation running at %0 times real-time").arg(timeMultiplier)));
    }

};

int main(int argc, char* argv[])
{
	gsl_init();

	myWorld m_World(ArenaWidth, ArenaWidth, Color(0.9, 0.9, 0.9), MaximumStepSize);

	if (strcmp(argv[1], "viewer") == 0){
		unsigned timeMultiplier = 1;
		QApplication app(argc, argv);
		EnkiViewer viewer(&m_World, timeMultiplier);
		viewer.show();
		viewer.addRobots(m_World, 10);
		return app.exec();
	}
	else if (strcmp(argv[1], "noviewer") == 0){
		m_World.run();
		return 0;
	}
	else{
		std::cerr << "First argument must either be viewer or noviewer" << std::endl;
		return 2;
	}
}

void gsl_init()
{
	gsl_rng_free(rng);
	unsigned long int Seed;
	struct timeval tv;
    struct timezone tz;
    gettimeofday(&tv,&tz);
    Seed = tv.tv_sec * 1000000 + tv.tv_usec;
    rng = gsl_rng_alloc(gsl_rng_default);
    gsl_rng_set(rng, Seed);

    cout << "Seed: " << Seed << endl;
}

