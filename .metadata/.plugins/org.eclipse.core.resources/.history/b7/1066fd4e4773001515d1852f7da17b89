#include <sys/stat.h>
#include "aggregation.h"
#include "parameters.h"


/*
void Behavior()
{	
	Enki::World World (50, 50);
	std::vector< Enki::EPuck * > EPucks;

	for (int i = 0; i < (NumberOfAgent); i++){
		EPucks.push_back(new Enki::EPuck(0));  //sensor ability: none; noise: 0.05
		World.addObject(EPucks[i]);
	}
	InitializeConfiguration(EPucks);

	unsigned timeMultiplier = 1;
	QApplication app(argc, argv);
	EnkiTestViewer viewer(&world, timeMultiplier);
	viewer.show();

//	return app.exec();

	for(int Step = 0; Step < NumberOfTimeSteps; Step++)
	{

		World.step(TimeStep, OversamplingRate);

		SendAgentController(EPucks);

		ComputingAgentSpeed(EPucks, Step);

		PositionOutput(EPucks, Step);

	}

//	cout << "counter_agent: " << counter_agent << " " << "counter_nothing: " << counter_nothing << endl;

} */

void PositionOutput(const std::vector< Enki::EPuck*>& EPucks, const int Step)
{
    for (int i=0; i< (NumberOfAgent); i++){

//		cout << "linear speed: " << V_linear[i][Step] << " angular speed: " << V_angle[i][Step] << endl;
		PositionsFile << EPucks[i]->pos.x << " " << EPucks[i]->pos.y << " " << EPucks[i]->angle << " ";

    }

	PositionsFile << endl;
}

void ComputingAgentSpeed(const std::vector< Enki::EPuck*>& EPucks, const int Step)
{

	static std::vector<double> past_angle(NumberOfAgent);
	static std::vector<Enki::Vector > past_position(NumberOfAgent);

	for (int i = 0; i < (NumberOfAgent); i++)
	{
		if (Step == 0){
			past_position[i] = EPucks[i]->pos;
			past_angle[i] = EPucks[i]->angle;
		}

		double delta_distance = (EPucks[i]->pos - past_position[i]).norm();
		V_linear[i][Step] = delta_distance/TimeStep;
		V_linear[i][Step] = V_linear[i][Step]/EPuckMaximumSpeed;             //normalized

		Enki::Vector delta_position = (EPucks[i]->pos - past_position[i]);
		Enki::Vector face_vector(cos(past_angle[i]), sin(past_angle[i]));
		if ((delta_position * face_vector) < 0)
		{
			V_linear[i][Step] = -V_linear[i][Step];
		}
		past_position[i] = EPucks[i]->pos;

		double delta_angle = (EPucks[i]->angle - past_angle[i]);
		if ((delta_angle >= M_PI))
		{
			delta_angle = delta_angle - 2*M_PI;
		}
		else if ((delta_angle <= -M_PI))
		{
			delta_angle = delta_angle + 2*M_PI;
		}

		V_angle[i][Step] = delta_angle/TimeStep;
		V_angle[i][Step] = V_angle[i][Step]*5.1/(EPuckMaximumSpeed*2);       //normalized
		past_angle[i] = EPucks[i]->angle;

	}
}


