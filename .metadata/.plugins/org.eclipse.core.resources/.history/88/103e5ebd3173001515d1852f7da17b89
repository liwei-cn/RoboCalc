#include <cstdlib>
#include <cstring>
#include <sys/time.h>
#include <sys/stat.h>
#include <math.h>
#include "aggregation.h"
#include "parameters.h"

#include "viewer/Viewer.h"
#include <enki/PhysicalEngine.h>
#include <enki/robots/e-puck/EPuck.h>
#include <QtGui/QApplication>
#include <QtGui/QtGui>
#include <iostream>
#include <fstream>

const gsl_rng_type *T;
gsl_rng *r;
ofstream PositionsFile;
stringstream filename, directoryname, in_file_path;
ifstream input_file;

double V_linear[NumberOfAgent][NumberOfTimeSteps];
double V_angle[NumberOfAgent][NumberOfTimeSteps];
double AnimalController[4] = {-0.7, -1.0, 1.0, -1.0};

const double ctrl_stepsize = 1./10.;
const unsigned maxSteps = 10;

void gsl_init();
void output_init();

using namespace Enki;
using namespace std;

/* Implement specifics of my world */
class EnkiTestWorld : public World
{
    public:
		EnkiTestWorld(double width, double height, unsigned maxSteps) :
        	Enki::World(width, height), maxSteps(maxSteps)
        {
        	c_step = 0;
			for (int i = 0; i < (NumberOfAgent); i++){
				epucks.push_back(new Enki::EPuck(0));  //sensor ability: none; noise: 0.05
				addObject(epucks[i]);
			}
        }

		void createAgent()
		{
			Agent* a = new Agent();
			// make sure that the agent does not overlap with existing agents
			Enki::Point new_pos;
			bool conflict = true;
			unsigned c_conflict = 0;
			while (conflict)
			{
				// choose a new position in the bottom half of the arena
				conflict = false;
				const double LengthOfSides = arenaSize;
				new_pos = Enki::Point(
						LengthOfSides*gsl_rng_uniform(r),
						LengthOfSides*gsl_rng_uniform(r);
				);

				// check if the agent overlapp some other in this position
				for (Enki::World::ObjectsIterator i = objects.begin(); i != objects.end(); ++i)
				{
					Agent* other = dynamic_cast<Agent*>(*i);
					if (other)
					{
						if ((other->pos - new_pos).norm2() < 4. * d_robot_radius * d_robot_radius)
						{
							conflict = true;
							c_conflict++;
							if (c_conflict > c_agent * c_agent + 1000)
							{
								std::cerr << "Aborting because of too many attempts to put agent in the arena." << std::endl;
								exit(1);
							}
							break;
						}
					}
				}
				if (conflict == false)
				{
					c_conflict = 0;
				}
			}

			a->pos = new_pos;
			a->angle = UniformRand(0, 2.*M_PI)();
			addObject(a);
		}
    	// returns true if the total simulation period has elapsed
    	bool runStep()
    	{
    		if (c_step != maxSteps)
    		{
    			step(ctrl_stepsize, 10);
    			c_step++;
    			return false;
    		}
    		return true;
    	}


    	void run()
    	{
    		bool finished = false;
    		while (finished == false)
    		{
    			finished = runStep();
    		}
    	}
    private:
        unsigned maxSteps;
        unsigned c_step;
        std::vector< Enki::EPuck * > epucks;
        /* Extend virtual funtion controlStep, where the dynamics of the world
         * are specified */
};

class EnkiTestViewer : public ViewerWidget
{
protected:
	unsigned timeMultiplier;
	int timerId;
	EnkiTestWorld* myworld;

public:
	EnkiTestViewer(EnkiTestWorld *world, unsigned timeMultiplier = 1, QWidget *parent = 0) :
		ViewerWidget(world, parent),
		timeMultiplier(timeMultiplier)
	{
		myworld = world;
		timerId = startTimer(100);
        // Define viewer camera position and altitudes
        altitude= world->h;
        pos = QPointF(-world->w * 0.5, -world->h * 0);
	}

	virtual void timerEvent(QTimerEvent * event)
	{
		if (event->timerId() == timerId)
		{
			bool finished = false;
			for (unsigned i = 0; i < timeMultiplier; i++)
			{
				finished =  myworld->runStep();
				if (finished)
					break;
			}
			updateGL();

			if (finished)
				close();
		}
	}

	virtual void wheelEvent(QWheelEvent * event)
	{
		if (event->delta() > 0)
			timeMultiplier *= 2;
		else if (event->delta() < 0 && timeMultiplier > 1)
			timeMultiplier /= 2;
		setWindowTitle(QString(tr("Simulation runnig at %0 times real-time").arg(timeMultiplier)));
	}

};

int main(int argc, char* argv[])
{
	gsl_init();
	output_init();

//	Enki::World myWorld (arenaSize, arenaSize);
//	std::vector< Enki::EPuck * > EPucks;
//
//	for (int i = 0; i < (NumberOfAgent); i++){
//		EPucks.push_back(new Enki::EPuck(0));  //sensor ability: none; noise: 0.05
//		myWorld.addObject(EPucks[i]);
//	}
//	InitializeConfiguration(EPucks);

	EnkiTestWorld myWorld(arenaSize, arenaSize, maxSteps);

	unsigned timeMultiplier = 1;
	QApplication app(argc, argv);
	EnkiTestViewer viewer(&myWorld, timeMultiplier);
	viewer.show();

	return app.exec();

//	return 0;
}

void gsl_init()
{
	gsl_rng_free(r);
	unsigned long int Seed;
	struct timeval tv;
    struct timezone tz;
    gettimeofday(&tv,&tz);
    Seed = tv.tv_sec * 1000000 + tv.tv_usec;
    T = gsl_rng_default;
    r = gsl_rng_alloc(T);
    gsl_rng_set(r, Seed);

    cout << "Seed: " << Seed << endl;
}

void output_init()
{

	directoryname << "./Out/";
    mkdir(directoryname.str().c_str(), S_IRWXU);
    filename << directoryname.str() << "Positions.txt";

    PositionsFile.open(filename.str().c_str(), std::ios::trunc);

    if (!PositionsFile)
    {
    	cout << "Error: Can't open the position file.\n";
        exit(1);
    }

}
