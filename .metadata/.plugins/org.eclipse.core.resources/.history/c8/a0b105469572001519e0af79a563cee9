#include "viewer/Viewer.h"
#include <enki/PhysicalEngine.h>
#include <enki/robots/e-puck/EPuck.h>
#include <QtGui/QApplication>
#include <QtGui/QtGui>
#include <sys/stat.h>
#include <iostream>
#include <fstream>
#include "aggregation.h"
#include "parameters.h"

using namespace Enki;
using namespace std;

class EnkiTestViewer : public ViewerWidget
{
protected:
	EPuck *epuck;
	unsigned timeMultiplier;
	int timerId;
	EnkiTestWorld* myworld;

public:
	EnkiTestViewer(EnkiTestWorld *world, unsigned timeMultiplier = 1, QWidget *parent = 0) :
		ViewerWidget(world, parent),
		timeMultiplier(timeMultiplier)
	{
		myworld = world;
		timerId = startTimer(100);
	}

	virtual void timerEvent(QTimerEvent * event)
	{
		if (event->timerId() == timerId)
		{
			bool finished = false;
			for (unsigned i = 0; i < timeMultiplier; i++)
			{
				finished =  myworld->runStep();
				if (finished)
					break;
			}
			updateGL();

			if (finished)
				close();
		}
	}

	virtual void wheelEvent(QWheelEvent * event)
	{
		if (event->delta() > 0)
			timeMultiplier *= 2;
		else if (event->delta() < 0 && timeMultiplier > 1)
			timeMultiplier /= 2;
		setWindowTitle(QString(tr("Simulation runnig at %0 times real-time").arg(timeMultiplier)));
	}

};



void Behavior()
{	
	Enki::World World;
	std::vector< Enki::EPuck * > EPucks;

	for (int i = 0; i < (NumberOfAnimals+NumberOfModels); i++){
		EPucks.push_back(new Enki::EPuck(0));  //sensor ability: none; noise: 0.05
		World.addObject(EPucks[i]);
	}
	InitializeConfiguration(EPucks);
	for(int Step = 0; Step < NumberOfTimeSteps; Step++)
	{

		World.step(TimeStep, OversamplingRate);

		SendAgentController(EPucks);

		ComputingAgentSpeed(EPucks, Step);

		PositionOutput(EPucks, Step);

	}

//	cout << "counter_agent: " << counter_agent << " " << "counter_nothing: " << counter_nothing << endl;

}

void InitializeConfiguration(std::vector< Enki::EPuck*>& EPucks)
{

	for(int i = 0; i < (NumberOfAnimals+NumberOfModels); i++)
	{
		double xi;
		double yi;

		bool Overlap;

		do
		{
			const double LengthOfSides = sqrt(AreaPerRobot*(NumberOfAnimals+NumberOfModels));
			xi = LengthOfSides*gsl_rng_uniform(r);
		    yi = LengthOfSides*gsl_rng_uniform(r);
			Overlap = false;

			for (int j = 0; j < i; j ++ )
			{
				double xj = EPucks[j]->pos.x;
				double yj = EPucks[j]->pos.y;

				double dij = sqrt(pow(xi - xj, 2.0) + pow(yi - yj, 2.0));

				if (dij < (2.0 * EPuckRadius))
				{
					Overlap = true;
					break;
				}
			}

		} while(Overlap == true);

		EPucks[i]->pos.x = xi;
		EPucks[i]->pos.y = yi;
		EPucks[i]->angle = 2.0*M_PI*(gsl_rng_uniform(r) - 0.5);
	}

}

int ComputeSensorReading(const std::vector< Enki::EPuck*>& EPucks, const int Index, const double theta)
{
	double Output = 0;

	for(int j = 0; j < (NumberOfAnimals+NumberOfModels); j ++ )
		if( j != Index )
		{

			const double xi = EPucks[Index]->pos.x;
			const double yi = EPucks[Index]->pos.y;
			const double ai = EPucks[Index]->angle;

			const double xj = EPucks[j]->pos.x;
			const double yj = EPucks[j]->pos.y;

			const double Side1 = sin(ai+theta/2)*(yj - yi) + cos(ai+theta/2)*(xj - xi);
			const double PerpendicularDistance1 = fabs((yi - yj)*cos(ai+theta/2) - (xi - xj)*sin(ai+theta/2));

			const double Side2 = sin(ai-theta/2)*(yj - yi) + cos(ai-theta/2)*(xj - xi);
			const double PerpendicularDistance2 = fabs((yi - yj)*cos(ai-theta/2) - (xi - xj)*sin(ai-theta/2));

			double delta = fabs(atan2(yj-yi,xj-xi) - ai);
			if (delta > M_PI)
			{
				delta = 2*M_PI - delta;
			}
			if(((Side1 > 0 && PerpendicularDistance1 <= EPuckRadius)||(Side2 > 0 && PerpendicularDistance2 <= EPuckRadius) || (delta < theta/2)))
			{
				Output = 1;
				break;
			}

		}

	return Output;
}

int ComputeSensorReading(const std::vector< Enki::EPuck*>& EPucks, const int &Index)
{
	double Output = 0;
	for(int j = 0; j < (NumberOfAnimals+NumberOfModels); j ++ )
		if( j != Index )
		{
			const double xi = EPucks[Index]->pos.x;
			const double yi = EPucks[Index]->pos.y;
			const double ai = EPucks[Index]->angle;

			const double xj = EPucks[j]->pos.x;
			const double yj = EPucks[j]->pos.y;

			const double Side = -sin(ai)*(yi - yj) - cos(ai)*(xi - xj);
			const double PerpendicularDistance = fabs((yi - yj)*cos(ai) - (xi - xj)*sin(ai));

			if(Side > 0 && PerpendicularDistance <= EPuckRadius)
			{
				Output = 1;
				break;
			}
		}

	return Output;
}


void PositionOutput(const std::vector< Enki::EPuck*>& EPucks, const int Step)
{
    for (int i=0; i< (NumberOfAnimals+NumberOfModels); i++){

//		cout << "linear speed: " << V_linear[i][Step] << " angular speed: " << V_angle[i][Step] << endl;
		PositionsFile << EPucks[i]->pos.x << " " << EPucks[i]->pos.y << " " << EPucks[i]->angle << " ";

    }

	PositionsFile << endl;
}

void ComputingAgentSpeed(const std::vector< Enki::EPuck*>& EPucks, const int Step)
{

	static std::vector<double> past_angle(NumberOfAnimals+NumberOfModels);
	static std::vector<Enki::Vector > past_position(NumberOfAnimals+NumberOfModels);

	for (int i = 0; i < (NumberOfAnimals+NumberOfModels); i++)
	{
		if (Step == 0){
			past_position[i] = EPucks[i]->pos;
			past_angle[i] = EPucks[i]->angle;
		}

		double delta_distance = (EPucks[i]->pos - past_position[i]).norm();
		V_linear[i][Step] = delta_distance/TimeStep;
		V_linear[i][Step] = V_linear[i][Step]/EPuckMaximumSpeed_Animal;             //normalized

		Enki::Vector delta_position = (EPucks[i]->pos - past_position[i]);
		Enki::Vector face_vector(cos(past_angle[i]), sin(past_angle[i]));
		if ((delta_position * face_vector) < 0)
		{
			V_linear[i][Step] = -V_linear[i][Step];
		}
		past_position[i] = EPucks[i]->pos;

		double delta_angle = (EPucks[i]->angle - past_angle[i]);
		if ((delta_angle >= M_PI))
		{
			delta_angle = delta_angle - 2*M_PI;
		}
		else if ((delta_angle <= -M_PI))
		{
			delta_angle = delta_angle + 2*M_PI;
		}

		V_angle[i][Step] = delta_angle/TimeStep;
		V_angle[i][Step] = V_angle[i][Step]*5.1/(EPuckMaximumSpeed_Animal*2);       //normalized
		past_angle[i] = EPucks[i]->angle;

	}
}

void SendAgentController(const std::vector< Enki::EPuck*>& EPucks)
{
	for (int i = 0; i < (NumberOfAnimals+NumberOfModels); i++){

		double SensorReading = ComputeSensorReading(EPucks, i);
		if (SensorReading == 0){
			EPucks[i]->leftSpeed  = EPuckMaximumSpeed_Animal*AnimalController[0];
			EPucks[i]->rightSpeed = EPuckMaximumSpeed_Animal*AnimalController[1];
		}
		else if (SensorReading == 1){
			EPucks[i]->leftSpeed  = EPuckMaximumSpeed_Animal*AnimalController[2];
			EPucks[i]->rightSpeed = EPuckMaximumSpeed_Animal*AnimalController[3];
		}

	}
}

