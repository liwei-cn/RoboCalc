#include <cstdlib>
#include <cstring>
#include <sys/time.h>
#include <sys/stat.h>
#include <math.h>
#include "aggregation.h"
#include "parameters.h"

#include "viewer/Viewer.h"
#include <enki/PhysicalEngine.h>
#include <enki/robots/e-puck/EPuck.h>
#include <QtGui/QApplication>
#include <QtGui/QtGui>
#include <iostream>
#include <fstream>

gsl_rng *rng;
ofstream PositionsFile;
stringstream filename, directoryname, in_file_path;
ifstream input_file;

double V_linear[NumberOfAgent][NumberOfTimeSteps];
double V_angle[NumberOfAgent][NumberOfTimeSteps];
double AnimalController[4] = {-0.7, -1.0, 1.0, -1.0};

const double ctrl_stepsize = 1./10.;
const unsigned maxSteps = 10;

void gsl_init();
void output_init();

using namespace Enki;
using namespace std;

/* Implement specifics of my world */
class EnkiTestWorld : public World
{
    public:
		EnkiTestWorld(double width, double height, unsigned maxSteps) :
        	Enki::World(width, height), maxSteps(maxSteps)
        {
        	c_step = 0;
			for (int i = 0; i < (NumberOfAgent); i++){
				epucks.push_back(new Enki::EPuck(0));  //sensor ability: none; noise: 0.05
				addObject(epucks[i]);
			}
        }

		void InitializeConfiguration()
		{

			for(int i = 0; i < (NumberOfAgent); i++)
			{
				double xi;
				double yi;

				bool Overlap;

				do
				{
		//			const double LengthOfSides = sqrt(AreaPerRobot*(NumberOfAgent+NumberOfModels));
					const double LengthOfSides = arenaSize;
					xi = LengthOfSides*gsl_rng_uniform(rng);
				    yi = LengthOfSides*gsl_rng_uniform(rng);
					Overlap = false;

					for (int j = 0; j < i; j ++ )
					{
						double xj = epucks[j]->pos.x;
						double yj = epucks[j]->pos.y;

						double dij = sqrt(pow(xi - xj, 2.0) + pow(yi - yj, 2.0));

						if (dij < (2.0 * EPuckRadius))
						{
							Overlap = true;
							break;
						}
					}

				} while(Overlap == true);

				epucks[i]->pos.x = xi;
				epucks[i]->pos.y = yi;
				epucks[i]->leftSpeed = 12.8;
				epucks[i]->rightSpeed = 12.8;
				epucks[i]->angle = 2.0*M_PI*(gsl_rng_uniform(rng) - 0.5);
			}

		}
    	// returns true if the total simulation period has elapsed
    	bool runStep()
    	{
    		if (c_step != maxSteps)
    		{
    			step(ctrl_stepsize, 10);
    			c_step++;
    			return false;
    		}
    		return true;
    	}


    	void run()
    	{
    		bool finished = false;
    		while (finished == false)
    		{
    			finished = runStep();
    		}
    	}
    private:
        unsigned maxSteps;
        unsigned c_step;
        std::vector< Enki::EPuck * > epucks;
        /* Extend virtual funtion controlStep, where the dynamics of the world
         * are specified */
};

class EnkiTestViewer : public ViewerWidget
{
protected:
	unsigned timeMultiplier;
	int timerId;
	EnkiTestWorld* myworld;

public:
	EnkiTestViewer(EnkiTestWorld *world, unsigned timeMultiplier = 1, QWidget *parent = 0) :
		ViewerWidget(world, parent),
		timeMultiplier(timeMultiplier)
	{
		myworld = world;
		timerId = startTimer(100);
        // Define viewer camera position and altitudes
        altitude= world->h;
        pos = QPointF(-world->w * 0.5, -world->h * 0);
	}

	virtual void timerEvent(QTimerEvent * event)
	{
		if (event->timerId() == timerId)
		{
			bool finished = false;
			for (unsigned i = 0; i < timeMultiplier; i++)
			{
				finished =  myworld->runStep();
				if (finished)
					break;
			}
			updateGL();

			if (finished)
				close();
		}
	}

	virtual void wheelEvent(QWheelEvent * event)
	{
		if (event->delta() > 0)
			timeMultiplier *= 2;
		else if (event->delta() < 0 && timeMultiplier > 1)
			timeMultiplier /= 2;
		setWindowTitle(QString(tr("Simulation runnig at %0 times real-time").arg(timeMultiplier)));
	}

};

int main(int argc, char* argv[])
{
	gsl_init();
	output_init();

//	Enki::World myWorld (arenaSize, arenaSize);
//	std::vector< Enki::EPuck * > EPucks;
//
//	for (int i = 0; i < (NumberOfAgent); i++){
//		EPucks.push_back(new Enki::EPuck(0));  //sensor ability: none; noise: 0.05
//		myWorld.addObject(EPucks[i]);
//	}
//	InitializeConfiguration(EPucks);

	EnkiTestWorld myWorld(arenaSize, arenaSize, maxSteps);

	unsigned timeMultiplier = 1;
	QApplication app(argc, argv);
	EnkiTestViewer viewer(&myWorld, timeMultiplier);
	viewer.show();

	return app.exec();

//	return 0;
}

void gsl_init()
{
	gsl_rng_free(r);
	unsigned long int Seed;
	struct timeval tv;
    struct timezone tz;
    gettimeofday(&tv,&tz);
    Seed = tv.tv_sec * 1000000 + tv.tv_usec;
    rng = gsl_rng_alloc(gsl_rng_default);
    gsl_rng_set(rng, Seed);

    cout << "Seed: " << Seed << endl;
}

void output_init()
{

	directoryname << "./Out/";
    mkdir(directoryname.str().c_str(), S_IRWXU);
    filename << directoryname.str() << "Positions.txt";

    PositionsFile.open(filename.str().c_str(), std::ios::trunc);

    if (!PositionsFile)
    {
    	cout << "Error: Can't open the position file.\n";
        exit(1);
    }

}
